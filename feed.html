<html><head>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <style>
        body {
            background-color: #104030;
            font-family: verdana, tahoma, geneva, sans-serif;
            font-size: 24px;
        }

        p {
            line-height: 2.0;
        }

        a {
        	text-decoration: none
        }

        a.good {
            color: #008000;
        }

        a.bad {
            color: #800000;
        }

        a:hover {
        	text-decoration: underline;
        }

        div.header {
            background: #50a090;
            padding-left: 6px;
        }

        div.op {
            background: #ffffff;
            border-radius: 20px;
            padding: 5px;
            margin-top: 20px;
            margin-left: 20px;
            margin-right: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2), 0 6px 20px 0 rgba(0, 0, 0, 0.19);
        }

        div.notifs {
            background: #70c0b0;
            border-radius: 20px;
            margin-top: 20px;
            margin-left: 20px;
            margin-right: 20px;
            margin-bottom: 20px;
            padding: 20px;
            border: 1px solid #004000;
        }

        tr.notif_unread {
            background-color: #90e0d0;
        }

        div.padded {
            padding: 5px;
        }

        div.hidden {
            display: none;
        }

        div.indent {
            margin-left: 40px;
        }

        div.scrollbox {
            height: 200px;
            overflow-y: scroll;
        }

        div.rp_color {
            background: #f0f4f0;
        }

        div.rate_color {
            background: #f8f8e0;
        }

        div.bubble {
            border-radius: 20px;
            border: 1px solid #808080;
            padding: 7px;
        }

        img.rounded {
            border-radius: 7px;
        }

        .tool {
        }

        .tool_anchor {
            position: relative;
            width: 0;
            height: 0;
        }

        .tool .tooltip {
            visibility: hidden;
            width: 350px;
            background-color: #d0b0a0;
            color: black;
            text-align: center;
            border-radius: 10px;
            border: 1px solid #808080;
            padding: 15px 5;
            z-index: 1;
            position: absolute;
            left: 30px;
            top: 0px;
        }

        .tool:hover .tooltip {
            visibility: visible;
        }
    </style>
    <script type="text/javascript">
//<globals>//
let rev = 0;
let op_revs = [];


let tag_lines = [
    "An anti-social network.<br>You learn more from foes than friends.",
    "Social media exists to<br>validate your stupid ideas.<br>We exist to crush them.",
    "Got an opinion you can't back up?<br>Great, keep it to yourself.",
    "Hate criticism and love validation?<br>Go away. You're not welcome here.",
    "Love caps lock? Hate grammar Nazis?<br>Maybe Facebook is for you.",
    "We're not here to spread alleged facts.<br>We discuss reasons.",
    "As the pen is to the sword,<br>so debate is to war.",
];
let unbiased_indexes = {};
let biased_indexes = {};
let unbiased_scores = {};
let biased_scores = {};

// -------------
// Slider widget
// -------------
function slider_mouse_down(id) {
	window.activeSliderId = id;
	return false;
}

function slider_mouse_up(e_event, b_watching) {
	if (window.activeSliderId != null) {
		var slider = window.active_sliders[window.activeSliderId];
		slider.set_value(slider.minValue + (slider.is_vertical
			? (slider.pathLength - parseInt(slider.el_slider.style.top) + slider.pathTop)
			: (parseInt(slider.el_slider.style.left) - slider.pathLeft)) / slider.pix2value);
		if (b_watching)	return;
		window.activeSliderId = null;
	}
	if (window.saved_mouse_up)
		return window.saved_mouse_up(e_event);
}

function slider_mouse_move(e_event) {

	if (!e_event && window.event) e_event = window.event;

	// save mouse coordinates
	if (e_event) {
		window.mouseX = e_event.clientX + slider_filter_results (
			window.pageXOffset ? window.pageXOffset : 0,
			document.documentElement ? document.documentElement.scrollLeft : 0,
			document.body ? document.body.scrollLeft : 0
		);
		window.mouseY = e_event.clientY + slider_filter_results (
			window.pageYOffset ? window.pageYOffset : 0,
			document.documentElement ? document.documentElement.scrollTop : 0,
			document.body ? document.body.scrollTop : 0
		);
	}

	// check if in drag mode
	if (window.activeSliderId != null) {
		var slider = window.active_sliders[window.activeSliderId];
		var pxOffset;
		if (slider.is_vertical) {
			var sliderTop = window.mouseY - slider.sliderHeight / 2 - slider.get_abs_pos(1, 1) - 3;
			// limit the slider movement
			if (sliderTop < slider.pathTop)
				sliderTop = slider.pathTop;
			var pxMax = slider.pathTop + slider.pathLength;
			if (sliderTop > pxMax)
				sliderTop = pxMax;
			slider.el_slider.style.top = sliderTop + 'px';
			pxOffset = slider.pathLength - sliderTop + slider.pathTop;
		}
		else {
			var sliderLeft = window.mouseX - slider.sliderWidth / 2 - slider.get_abs_pos(0, 1) - 3;
			// limit the slider movement
			if (sliderLeft < slider.pathLeft)
				sliderLeft = slider.pathLeft;
			var pxMax = slider.pathLeft + slider.pathLength;
			if (sliderLeft > pxMax)
				sliderLeft = pxMax;
			slider.el_slider.style.left = sliderLeft + 'px';
			pxOffset = sliderLeft - slider.pathLeft;
		}
		slider_mouse_up(e_event, 1);
		return false;
	}
	if (window.saved_mouse_move)
		return window.saved_mouse_move(e_event);
}

function slider_filter_results(win, docel, body) {
	var result = win ? win : 0;
	if (docel && (!result || (result > docel)))
		result = docel;
	return body && (!result || (result > body)) ? body : result;
}

class Slider {
	constructor(bg_filename, bg_wid, bg_hgt, fg_filename, fg_wid, fg_hgt, initial_val, on_change) {
		// Register in a global collection
		if (!window.active_sliders)
			window.active_sliders = [];
		this.id = window.active_sliders.length;
		window.active_sliders[this.id] = this;

		this.is_vertical = false;
		this.sliderWidth = fg_wid;
		this.sliderHeight = fg_hgt;
		this.pathLeft = 1;
		this.pathTop = 1;
		this.pathLength = 300;
		this.minValue = 5;
		this.maxValue = 105;
		this.step = 5;
		this.zIndex = 1;

		this.pix2value = this.pathLength / (this.maxValue - this.minValue);
		if (this.value == null)
			this.value = this.minValue;

		// generate the control's HTML
		document.write(
			'<div style="width:' + bg_wid + 'px;height:' + bg_hgt + 'px;border:0; background-image:url(' + bg_filename + ')" id="sl' + this.id + 'base">' +
			'<img src="' + fg_filename + '" width="' + fg_wid + '" height="' + fg_hgt + '" border="0" style="position:relative;left:' + this.pathLeft + 'px;top:' + this.pathTop + 'px;z-index:' + this.zIndex + ';cursor:pointer;visibility:hidden;" name="sl' + this.id + 'slider" id="sl' + this.id + 'slider" onmousedown="return slider_mouse_down(' + this.id + ')"/></div>'
		);
		this.el_base = document.getElementById('sl' + this.id + 'base');
		this.el_slider = document.getElementById('sl' + this.id + 'slider');

		// Hook up document/window events
		if (!window.saved_mouse_move && document.onmousemove != slider_mouse_move) {
			window.saved_mouse_move = document.onmousemove;
			document.onmousemove = slider_mouse_move;
		}
		if (!window.saved_mouse_up && document.onmouseup != slider_mouse_up) {
			window.saved_mouse_up = document.onmouseup;
			document.onmouseup = slider_mouse_up;
		}
		this.on_change = on_change;
		this.value = initial_val - 1;
		this.set_value(initial_val);
		this.el_slider.style.visibility = 'visible';
	}

	set_value(value) {
		if (value == null)
			value = this.value == null ? this.minValue : this.value;
		if (isNaN(value))
			return;

		// Round to closest step
		if (this.step)
			value = Math.round((value - this.minValue) / this.step) * this.step + this.minValue;

		// Round away extreme decimals (like .00001 or .99999)
		if (value % 1)
			value = Math.round(value * 1e5) / 1e5;

		// Set the value
		value = Math.min(this.maxValue, Math.max(this.minValue, value));

		// Move the slider
		if (this.is_vertical)
			this.el_slider.style.top  = (this.pathTop + this.pathLength - Math.round((value - this.minValue) * this.pix2value)) + 'px';
		else
			this.el_slider.style.left = (this.pathLeft + Math.round((value - this.minValue) * this.pix2value)) + 'px';

		// Report the change
		if (this.value === value) return;
		this.value = value;
		if (this.on_change)
			this.on_change(this, value);
	}

	// get absolute position of the element in the document
	get_abs_pos(is_vertical, is_base) {
		var pos = 0,
			s_coord = (is_vertical ? 'Top' : 'Left');
		var el = is_base ? this.el_base : this.el_slider;
		var el_old = el;

		while (el) {
			pos += el["offset" + s_coord];
			el = el.offsetParent;
		}
		el = el_old;

		var offset;
		while (el.tagName != "BODY") {
			offset = el["scroll" + s_coord];
			if (offset)
				pos -= el["scroll" + s_coord];
			el = el.parentNode;
		}
		return pos;
	}
}

// --------------
// Priority Queue
// --------------
const pq_parent = i => ((i + 1) >>> 1) - 1;
const pq_left = i => (i << 1) + 1;
const pq_right = i => (i + 1) << 1;
class PriorityQueue {
    constructor(comparator) {
        this._heap = [];
        this._comparator = comparator;
    }

    size() {
        return this._heap.length;
    }

    peek() {
        return this._heap[0];
    }

    push(value) {
        this._heap.push(value);
        this._siftUp();
    }

    pop() {
        const poppedValue = this.peek();
        const bottom = this.size() - 1;
        if (bottom > 0) {
            this._swap(0, bottom);
        }
        this._heap.pop();
        this._siftDown();
        return poppedValue;
    }

    _greater(i, j) { // greater means higher-priority
        return this._comparator(this._heap[i], this._heap[j]);
    }

    _swap(i, j) {
        [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]];
    }

    _siftUp() {
        let node = this.size() - 1;
        while (node > 0 && this._greater(node, pq_parent(node))) {
            this._swap(node, pq_parent(node));
            node = pq_parent(node);
        }
    }

    _siftDown() {
        let node = 0;
        while (
            (pq_left(node) < this.size() && this._greater(pq_left(node), node)) ||
            (pq_right(node) < this.size() && this._greater(pq_right(node), node))
        ) {
            let maxChild = (pq_right(node) < this.size() && this._greater(pq_right(node), pq_left(node))) ? pq_right(node) : pq_left(node);
            this._swap(node, maxChild);
            node = maxChild;
        }
    }
}

function httpPost(url, payload, callback)
{
    let request = new XMLHttpRequest();
    request.onreadystatechange = function()
    {
        if(request.readyState == 4)
        {
            if(request.status == 200)
            callback(request.responseText);
            else
            {
                if(request.status == 0 && request.statusText.length == 0)
                    alert("Connection failed");
                else
                    alert("Server returned status " + request.status + ", " + request.statusText);
            }
        }
    };
    request.open('post', url, true);
    request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    request.send(payload);
}

function outgoing(payload)
{
    payload.session_id = session_id;
    payload.path = path;
    payload.rev = rev;
    payload.ops = op_list;
    payload.opr = op_revs;
    httpPost("feed_ajax.html", JSON.stringify(payload), incoming);
}

function show_rate_div(id) {
    let x = document.getElementById(`m.${id}`);
    if (x.style.display === 'inline-block') {
        x.style.display = 'none';
    } else {
        x.style.display = 'inline-block';
    }
}

function show_reply_div(id) {
    let x = document.getElementById(`r.${id}`);
    if (x.style.display === 'inline-block') {
        x.style.display = 'none';
    } else {
        x.style.display = 'inline-block';
        let tb = document.getElementById(`t.${id}`);
        tb.focus();
    }
}

function get_parent_nursery_id(id)
{
    let last_dot = id.lastIndexOf('.');
    if (last_dot < 0) {
        return 'soil';
    } else {
        let parent_id = id.substr(0, last_dot);
        return `n.${parent_id}`;
    }
}

function find_or_make_node_div(id)
{
    // See if the div already exists
    let existing = document.getElementById(`d.${id}`);
    if (existing)
        return existing;

    // Make the new div
    let nursery_id = get_parent_nursery_id(id);
    let nursery_div = document.getElementById(nursery_id);
    if (!nursery_div)
        alert(`Received an update for a node I have not yet received: ${nursery_id}, ${path}`);
    new_div = document.createElement("div");
    new_div.id = `d.${id}`;
    nursery_div.appendChild(new_div);
    return new_div;
}

function node_comparator(a, b)
{
    isbiased = document.getElementById('isbiased').checked;
    if (isbiased) {
        return biased_scores[a] > biased_scores[b];
    } else {
        return unbiased_scores[a] > unbiased_scores[b];
    }
}

function update_hint(id)
{
    let hint_div = document.getElementById(`h.${id}`);
    if (hint_div) {
        isbiased = document.getElementById('isbiased').checked;
        let index = (isbiased ? biased_indexes[id] : unbiased_indexes[id]);
        let score = (isbiased ? biased_scores[id] : unbiased_scores[id]);
        if (score === undefined) {
            hint_div.innerHTML = '';
            console.log('Error, ratings hint was not provided');
        } else if (score >= 1000) {
            hint_div.innerHTML = ''; // unrated
        } else {
            if (index < 4) {
                hint_div.innerHTML = `<font color=#008000>${rating_choices[index]} (${score.toFixed(2)})</font>`;
            } else {
                hint_div.innerHTML = `<font color=#800000>${rating_choices[index]} (${score.toFixed(2)})</font>`;
            }
        }
    } else {
        console.log(`missing hint div h.${id}`);
    }
}

// Filter which comments are displayed or hidden.
// Update the rating hints.
function refresh_comments()
{
    thresh = parseInt(document.getElementById('thresh').innerHTML);
    if(!(thresh > 0 && thresh < 1000)) {
        alert('problem with thresh');
    }
    isbiased = document.getElementById('isbiased').checked;
    let q = new PriorityQueue(node_comparator);
    for (let i = 0; i < op_list.length; i++) { // For each OP...
        update_hint(op_list[i]);
        for (let j = 0; true; j++) { // For each pod...
            let pod_id = `${op_list[i]}.${j}`;
            let pod_nursery = document.getElementById(`n.${pod_id}`);
            if (!pod_nursery) {
                break;
            }

            // Seed the priority queue with the pod's immediate children
            for (let k = 0; true; k++) {
                let rp_id = `${pod_id}.${k}`;
                if (unbiased_scores[rp_id] === undefined) {
                    break;
                }
                q.push(rp_id);
            }

            // Pump in a breadth-first manner
            let nodes_shown = 0;
            while (q.size() > 0 && nodes_shown < thresh) {
                id = q.pop();

                // Update the ratings hing and show the div
                thediv = document.getElementById(`d.${id}`);
                if (thediv) {
                    update_hint(id);
                    thediv.style.display = 'block';
                } else {
                    alert('missing div ' + id);
                }
                nodes_shown++;

                // Add the children
                for (let j = 0; true; j++) {
                    let child_id = `${id}.${j}`;
                    if (unbiased_scores[child_id] !== undefined) {
                        q.push(child_id);
                    } else {
                        break;
                    }
                }
            } // ...while we haven't yet reached our threshold

            // Hide the remainder
            while (q.size() > 0) {
                let id = q.pop();
                thediv = document.getElementById(`d.${id}`);
                if (thediv) {
                    thediv.style.display = 'none';
                } else {
                    alert('missing div to hide d.' + id);
                }
            }
        } // ...for each pod in the OP
    } // ...for each OP
}

function closeRatings(id)
{
    let ratingsDiv = document.getElementById(`m.${id}`);
    ratingsDiv.style.display = 'none';
}

function submitRatings(id)
{
    let ratings = [];
    for (i = 0; i < rating_choices.length; i++) {
        let cb_id = `m${i}_${id}`;
        let cb = document.getElementById(cb_id);
        ratings.push(cb.checked ? 1 : 0);
    }
    outgoing({
        act: 'rate',
        id: id,
        ratings: ratings,
    });
    closeRatings(id);
}

function rate_one(id, index)
{
    let cb_id = `m${index}_${id}`;
    let cb = document.getElementById(cb_id);
    cb.checked = 1;
    submitRatings(id);
}

function closeReply(id)
{
    let replyDiv = document.getElementById(`r.${id}`);
    if (replyDiv)
        replyDiv.style.display = 'none';
}

function submitReply(id)
{
    let text_box = document.getElementById(`t.${id}`);
    let text = text_box.value;
    outgoing({
        act: 'comment',
        parid: id,
        text: text,
    });
    text_box.value = '';
    closeReply(id);
}

function showCreateMenu()
{
    let el = document.getElementById('newdebate');
    if (el.style.display !== 'inline-block') {
        el.style.display = 'inline-block';
    } else {
        el.style.display = 'none';
    }
}

function showNotifications()
{
    let el = document.getElementById('notifications');
    if (el.style.display !== 'inline-block') {
        outgoing({
            act: 'notifs',
        });
        el.style.display = 'inline-block';
    } else {
        el.style.display = 'none';
    }
}

function closeNotifs()
{
    let el = document.getElementById('notifications');
    el.style.display = 'none';
}

// pos is the position of notifications already read
// msgs is a list of all the notifications
function update_notifications(pos, msgs)
{
    let el = document.getElementById('notifications');
    let s = [];
    s.push('<div class="notifs">');
    s.push('<h3>Notifications</h3>');
    s.push('<table>');
    if (msgs.length === 0)
        s.push('(No notifications)');
    for (let i = msgs.length - 1; i >= 0; i--)
    {
        let msg = msgs[i];
        if (i >= pos)
            s.push('<tr class="notif_unread">');
        else
            s.push('<tr>');
        s.push('<td>');
        if (msg.image.length > 0)
            s.push(`<img class="rounded" src="${msg.image}">`);
        s.push('</td><td>');
        s.push(msg.name);
        if (msg.type === 'rate')
            s.push(' rated your post, ');
        else if (msg.type === 'rp')
            s.push(' replied to your post, ');
        else if (msg.type === 'op')
            s.push(' participated in your debate, ');
        else if (msg.type === 'chal')
            s.push(' challenged you to debate, ');
        else if (msg.type === 'acc')
            s.push(' accepted your debate challenge, ');
        else
            console.log(`Error, unrecognized notification ${msg.type}`);
        s.push(`<a href='?path=${msg.id}'>${msg.summ}</a>`);
        s.push('</td></tr>');
    }
    s.push('</table>');
    s.push('<br><button type="button" onclick="closeNotifs()">Close</button>');
    s.push('</div>');
    el.innerHTML = s.join('');
}

function closeCreateMenu()
{
    el = document.getElementById('newdebate');
    el.style.display = 'none';
}

function startNewDebate()
{
    sel = document.getElementById('choose_opponent');
    let mode = sel.value;
    text_box = document.getElementById('t_debate_topic');
    let text = text_box.value;
    let packet = {
        act: 'newop',
        parid: path,
        mode: mode,
        text: text,
    };
    if (mode === 'name') {
        let opponent_name = document.getElementById('opponent');
        packet.name = opponent_name.value;
    }
    outgoing(packet);
    text_box.value = '';
    closeCreateMenu();
}

function accept_challenge(pod_id)
{
    outgoing({
        act: 'accept',
        id: pod_id,
    });
}

// ID Prefixes:
// d = node id
// h = hint about rating
// m = moderation div
// n = nursery (div for child nodes)
// r = reply div
// u = reply text area counter


// s is an array of strings
// entry is an object that describes the entry
function add_rate_and_respond_links(s, entry, allow_reply)
{
    s.push(`<div id='h.${entry.id}'></div>`);
    s.push(`<a href="#javascript:void(0)" onclick="show_rate_div('${entry.id}')">rate</a><br>`);
    if (allow_reply) {
        s.push(`<a href="#javascript:void(0)" onclick="show_reply_div('${entry.id}')">reply</a><br>`);
    }
}

// s is an array of strings
// entry is an object that describes the entry
function add_moderation_div(s, entry)
{
    s.push(`<div class="hidden" id="m.${entry.id}">`);
    s.push('<div class="bubble rate_color">&nbsp;&nbsp<span class="tool">Do not rate positions or claims.<br>&nbsp;&nbsp;Rate the reasons presented to support them.<br>');
    s.push('<span class="tool_anchor"><span class="tooltip">Because truth is not identified by popularity. It is found in the pursuit of reasons that can withstand scrutiny.</span></span></span>');
    s.push('<table>');
    for (let row = 0; row < 6; row++) {
        s.push('<tr>');
        for (let col = 0; col < 3; col++) {
            s.push('<td>');
            let i = 3 * row + col;
            s.push(`<input type="checkbox" id="m${i}_${entry.id}">`);
            s.push('<span class="tool">');
            s.push(`<a class="${i < 4 ? "good" : "bad"}" onclick="rate_one('${entry.id}',${i})" href="javascript:void(0);">`);
            s.push(`<b>${rating_choices[i]}</b>`);
            s.push('</a>');
            s.push(`<span class="tool_anchor"><span class="tooltip">${rating_descr[i]}</span></span>`);
            s.push('</span>');
            s.push('</td>');
        }
        s.push('</tr>');
    }
    s.push('</table>');
    s.push(`<button type="button" onclick="submitRatings('${entry.id}')">Rate</button>`);
    s.push(`&nbsp;<button type="button" onclick="closeRatings('${entry.id}')">Cancel</button>`);
    s.push('<br><br></div><br><br></div>\n');
}

// s is an array of strings
// entry is an object that describes the entry
function add_response_div(s, entry)
{
    s.push(`<div class="hidden indent" id="r.${entry.id}">`);
    s.push(`<textarea id="t.${entry.id}" rows="2" cols="50" maxlength="1000" onkeyup="on_textarea_change(this, 'u.${entry.id}')"></textarea><br>`);
    s.push(`<button type="button" onclick="submitReply('${entry.id}')">Post</button>`);
    s.push(`&nbsp;<button type="button" onclick="closeReply('${entry.id}')">Cancel</button>`);
    s.push(`&nbsp;&nbsp;&nbsp;<span id="u.${entry.id}"></span>`);
    s.push('<br><br></div>\n');
}

// newDiv is a div to hold the content this function generates.
// entry is an update object from the server.
function make_cat(newDiv, entry)
{
    let s = [];
    let count = (entry.id.length == 0 ? 0 : entry.id.split(".").length);
    s.push(`<img src='spacer.png' width=${40*count}px height=1px>`);
    s.push('<big><big>');
    if (count > 0) {
        s.push('└─');
    }
    s.push(`<a href='?path=${entry.id}'>${entry.data.title}</a>\n`);
    s.push('</big></big><br>');
    if (entry.id == path) {
        s.push(`<p>${entry.data.descr}</p><br><br>\n`);
    }
    s.push(`<div id="n.${entry.id}"></div>\n`);
    newDiv.innerHTML = s.join('');
}

// newDiv is a div to hold the content this function generates.
// entry is an update object from the server.
function make_op(newDiv, entry)
{
    newDiv.className = 'op';
    let s = [];
    s.push('<table><tr>');
    s.push(`<td valign=top align=right><img class="rounded" src="${entry.image}">`);
    s.push('</td><td width=4px></td>');
    s.push(`<td><b>${entry.name}</b><br>`);
    s.push(`<big><big>${entry.data.text}</big></big></td>`);
    s.push('<td valign=top>');
    add_rate_and_respond_links(s, entry, false);
    s.push('</td>');
    s.push('</tr></table>\n');
    add_moderation_div(s, entry);
    s.push(`<div id="n.${entry.id}"></div>\n`);
    newDiv.innerHTML = s.join('');
}

function make_pod(newDiv, entry)
{
    let s = [];
    s.push('<table><tr><td>');
    s.push('<table cellpadding=10px><tr>');
    s.push(`<td valign=top><h3>${entry.data.text}</h3></td>`);
    //s.push(`<td>${entry.id}</td>`);
    s.push('</tr></table>');
    s.push('</td></tr></table>\n');
    s.push(`<div class="indent" id="n.${entry.id}"></div>\n`);
    if (entry.ro === undefined) {
        s.push('<div class="indent">');
        s.push(`<textarea id="t.${entry.id}" rows="2" cols="50" maxlength="1000" onkeyup="on_textarea_change(this, 'u.${entry.id}')"></textarea><br>`);
        s.push(`<button type="button" onclick="submitReply('${entry.id}')">Post</button>`);
        s.push(`&nbsp;&nbsp;&nbsp;<span id="u.${entry.id}"></span></div>`);
        s.push('<br><br>\n');
    } else {
        if (entry.ro == 1) {
            s.push(`<br><div class="indent"><button type="button" onclick="accept_challenge('${entry.id}')">Accept this challenge</button></div></br>`);
        }
    }
    newDiv.innerHTML = s.join('');
}

// newDiv is a div to hold the content this function generates.
// entry is an update object from the server.
function make_rp(newDiv, entry)
{
    let s = [];
    let open_pod = (entry.ind === undefined ? true : false);

    s.push('<table><tr>');
    if (!open_pod) {
        let indent = (entry.ind !== 0);
        if (indent) {
            s.push('<td width="150px"></td>')
        }
    }
    s.push('<td>');
    s.push('<div class="bubble rp_color"><table><tr>');

    if (open_pod) {
        // Peanut gallery comment
        s.push(`<td valign=top align=right><img class="rounded" src="${entry.image}"></td><td width=4px></td>`);
        s.push('<td valign=top>');
        s.push(`<b>${entry.name}</b><br>`);
        s.push(entry.data.text);
        s.push('</td>');
    } else {
        // One-on-one debate comment
        let image_on_left = (entry.ind === 0 ? true : false)
        if (image_on_left)
            s.push(`<td valign=top align=right><img class="rounded" src="${entry.image}"></td><td width=4px></td>`);
        s.push('<td valign=top>');
        s.push(`<b>${entry.name}</b><br>`);
        s.push(entry.data.text);
        s.push('</td>');
        if (!image_on_left)
            s.push(`<td width=4px></td><td valign=top align=right><img class="rounded" src="${entry.image}"></td>`);
    }

    s.push('</tr></table></div>');
    s.push('</td><td valign=top>');
    add_rate_and_respond_links(s, entry, open_pod);
    s.push('</td></tr></table>\n');
    add_moderation_div(s, entry)
    s.push(`<div class="indent" id="n.${entry.id}"></div>\n`);
    if (open_pod) {
        add_response_div(s, entry)
    }
    newDiv.innerHTML = s.join('');
}

function store_ratings(entry)
{
    if (entry.ui !== undefined) {
        unbiased_indexes[entry.id] = entry.ui;
        biased_indexes[entry.id] = entry.bi;
        unbiased_scores[entry.id] = entry.us;
        biased_scores[entry.id] = entry.bs;
    }
}

function add_node(entry)
{
    let newDiv = find_or_make_node_div(entry.id);
    if (!newDiv) {
        console.log(`Ignoring irrelevant update to ${entry.id}`);
        return;
    }

    // Store ratings for the node
    store_ratings(entry);

    // Fill out the div content
    if (entry.data.type === 'rp') {
        make_rp(newDiv, entry);
        if (entry.id == path) {
            newDiv.scrollIntoView();
        }
    } else if (entry.data.type === 'pod') {
        make_pod(newDiv, entry);
    } else if (entry.data.type === 'op') {
        make_op(newDiv, entry);
    } else if (entry.data.type === 'cat') {
        make_cat(newDiv, entry);
    } else {
        let msg = `unrecognized entry type ${entry.data.type}`;
        alert(msg);
        throw msg;
    }
}

// Add a new OP to the list of OPs
function add_op(entry)
{
    op_list.splice(0, 0, entry.id); // insert entry.id at the front of the list
}

function set_focus(id)
{
    lastdot = id.lastIndexOf('.');
    if (parseInt(id.substr(lastdot + 1)) > 0) { // If the comment will appear somewhere else
        let node = document.getElementById(`d.${id}`);
        node.style.backgroundColor = '#ffff00';
        setTimeout(function() { node.style.backgroundColor = ''; }, 400);
        //node.scrollIntoView();
    }
}

function update_entry(entry)
{
    if (entry.act === 'add') {
        add_node(entry);
    } else if (entry.act === 'focus') {
        let id = entry.id;
        comment_count = entry.cc;
        rating_count = entry.rc;
        setTimeout(function() { set_focus(id); }, 200); // a little delay b/c the new comment may not be added yet
    } else if (entry.act === 'rate') {
        comment_count = entry.cc;
        rating_count = entry.rc;
        store_ratings(entry);
    } else if (entry.act === 'pushop') { // server wants to push an OP on us. (It's probably a new OP we just requested to have created.)
        add_op(entry);
        init();
    } else if (entry.act === 'alert') { // Display a message from the server
        alert(entry.msg);
    } else if (entry.act === 'notifs') { // Notifications
        update_notifications(entry.pos, entry.msgs);
    } else if (entry.act === 'nc') {
        let el = document.getElementById('notif_link');
        if (entry.val === 0)
            el.innerHTML = "Notifications";
        else
            el.innerHTML = `Notifications(${entry.val})`;
    } else {
        let msg = `unrecognized entry action ${entry.act}`;
        alert(msg);
        throw msg;
    }
}

function request_updates()
{
    outgoing({ act: 'update' });
}

function incoming(response)
{
    let ob = JSON.parse(response);
    if (ob.error !== undefined) {
        alert(`Error: ${ob.error}`);
        return;
    }
    if (ob.updates === undefined) {
        alert(`No updates in ${JSON.stringify(ob)}`);
    }
    for(entry of ob.updates) {
        update_entry(entry);
    }
    rev = ob.rev;
    op_list = ob.ops;
    op_revs = ob.opr;
    if (ob.updates.length > 0) {
        refresh_comments();
    }
}

function on_change_opponent(id)
{
    let sel = document.getElementById('choose_opponent');
    let opponent_name = document.getElementById('opponent_name_div');
    let val = sel.value;
    if (val === 'name') {
        opponent_name.style.display = 'inline-block';
    } else {
        opponent_name.style.display = 'none';
    }
}

function on_change_biased()
{
    refresh_comments();
}

function on_slider_change(slider, val)
{
    tb = document.getElementById('thresh');
    if(tb) {
        tb.innerHTML = '' + val;
        refresh_comments();
    }
}

function on_textarea_change(textarea, counter_id)
{
    // if (comment_count * 2 >= rating_count && textarea.value.length % 10 == 0) {
    //     alert(`Sorry, you have rated ${rating_count} comments and have posted ${comment_count}.\nA 2:1 ratio is required, so you must rate more comments before you may post.`);
    // }
    let count_span = document.getElementById(counter_id);
    chars_remaining = textarea.maxLength - textarea.value.length;
    count_span.innerHTML = chars_remaining < 500 ? chars_remaining : '';
}

function init()
{
    // Set the tag line
    let tagline = document.getElementById('tagline');
    tagline.innerHTML = tag_lines[Math.floor(Math.random() * tag_lines.length)];

    // Pull the content
    rev = 0;
    op_revs = [];
    for (let p of op_list) {
        op_revs.push(0);
    }
    request_updates();
}
</script>

</head><body>
<br><br>
<table bgcolor=#dddddd width=800 align=center><tr><td>

<div class="header">
    <table><tr>
        <td width=330>
            <big><big><big><big>DebateStuff.com</big></big></big></big><br>
            <div id='tagline'></div>
        </td>
        <td>
            <a onclick="showCreateMenu()" href="javascript:void(0);">New Debate</a>
            &nbsp;&nbsp;&nbsp;
            <a id="notif_link" onclick="showNotifications()" href="javascript:void(0);">Notifications</a>
            &nbsp;&nbsp;&nbsp;
            <a href="handbook.html">Handbook</a>
            &nbsp;&nbsp;&nbsp;
            <a href="account.html">Account</a>
            <br>
            <table cellpadding=10><tr>
                <td>
                    &nbsp;&nbsp;&nbsp;&nbsp;
                    <input type="radio" name="isbiased" onchange="on_change_biased();" checked>Unbiased
                    &nbsp;&nbsp;&nbsp;
                    <input type="radio" id="isbiased" name="isbiased" onchange="on_change_biased();">Biased<br>
                    <script language="JavaScript">myslider = new Slider('slider_bg.png', 321, 22, 'slider_tab.png', 19, 20, 25, on_slider_change);</script>
                    &nbsp;&nbsp;&nbsp;&nbsp;Show the top <span id="thresh">25</span> comments<br>
                </td>
            </tr></table>
    </td>
    </tr></table>

    <div id='notifications' class='hidden'>
    </div>
    <div id='newdebate' class='hidden'>
        <br><br>
        <h3>Whom would you like to debate?</h3>
        <select name="cars" id="choose_opponent" onchange="on_change_opponent()">
            <option value="first">Whomever first accepts the challenge</option>
            <option value="name">The individual named below</option>
            <option value="open">No one--let's just have an open discussion</option>
        </select><br>
        <div id='opponent_name_div' class="hidden">
            <br>Who would you like to challenge to debate?<br>
            <input type="text" id="opponent"><br>
        </div><br>
        <h3>Enter your debate topic.</h3>
        (A good debate topic makes <u>one</u> claim and provides <u>one</u> supporting reason.)<br>
        <textarea id="t_debate_topic" rows="2" cols="50"  maxlength="1500" onkeyup="on_textarea_change(this, 'u_debate_topic')"></textarea><br>
        <button type="button" onclick="startNewDebate()">Post</button>
        &nbsp;<button type="button" onclick="closeCreateMenu()">Cancel</button>
        &nbsp;&nbsp;&nbsp;<span id="u_debate_topic"></span>
        <br><br>
    </div>
</div>

<div id='soil'></div>
</td></tr></table>
<br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br>

<script type="text/javascript">
init();
let timer = setInterval(function() { request_updates(); }, 2000);
</script>

</body></html>
